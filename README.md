# Interview Practice

This site is dedicated to helping those that are trying to land a job as a Java programmer and they are facing any number of coding interviews and/or pre-interview coding assignments that potential employers have you do even before you are asked for a real interview. One philosophy that I will attempt to follow is that "regular" programmers solve problems using good algorithms, but "good" programmers solve problems using both good data structures and good algorithms. So, where ever I can make use of a standard data structure in order to either simplify the solution or to reduce the computational time of the solution, I will try to do so.
The following sections will discuss the data structures and problems that computer programmers and data scientists try to solve.

## Data Structures
It is advisable that a person preparing for a Java coding interview be able to implement any standard Java data structure. The simplest structures include the ArrayList, HashSet, and HashMap. It is a good idea to actually write your own implementations of these structures and test them out when you are writing a solution to a problem. You may learn more about how the Java language thgis way. Even if you do not do that, it is important to know how they work because questions about java's implementations of their structures comes up in interview **all the time**.
In addition, there are data structures that are used in solving problems that are not part of standard language. This website under the src folder contains data structures that I have implemented and some of them I use in problem solutions. The following sections discusses them.

### Union Find
This structure is used when there are a known number of descrete data points and the solution requires these data points be arranged into groups of related data points. As such, the UnionFind's constructor requires to know the number of data points in the solution. When the UnionFind is constructed, all data points are not associated to any other point, i.e. each point is associated to itself only. There are two basic methods that allow you to query and modify the structure. The first is the union(pointA, pointB) which modifies the structure to assoiates pointA to pointB. The second method queries two points to see if they are related. The find(pointA, pointB) method returns a boolean true if points pointA and pointB are associated. Since I used Robert Sedgewick's implementation of this structure in which all associated points are connected in trees, I/we have added a root(point) that returns the root node of the point given.
In addition to the root(point) method, I added internal storage that tracks both lists of connected points and a set of single points. Since the solutiuons in which I have used the UnionFind have needed to track this information and it cuts out a full O(n) from the time complexity, I added it. Never the less, this adds a "n" (plus overhead) space allocation to this structure. So if that is an issue for your solution, then you can create the map every time that the getConnectedLists() method is called and you UF will behave the same way.
I have included a utility package (UnionFindUtils) that can fill a UnionFind structure from a character or string matrix. This is helpful because the input for many problems are in either of these formats.
Since I have used this structure in the solutions of a few problems, I discuss the usage of this structure in the sub-sections of the Problems section ahead.

### Priority Queue
The standard priority queue stores queued data in a sorted for where the greatest element is always at the "top". This is done by implementing a heap. A heap is a tree where the root node is always the greatest node. When instanciated, the queue is empty. There are two public methods that interact with the Priority Queue's data. The insert(Key) adds a new key to the queue and deleteMax() deletes maximum (root) from the heap and returns it. There are two private methods, sink and swim, that adjust the heap whenever it is modified. (Robert Sedgewick).

## Topcoder Data Sciencs Problems
This website under the src folder contains solutions for Topcoder Data Science problems. This section is dedicated to explaining the solutions that I have coded for these problems. Please review each  problem on https://www.topcoder.com/ before reading my code and explanations. I invite anyone who can come up with a better solution offer it here.

### Capture Them All
I implemented this solution as a Breath First Search (BFS) with a small difference. This problem requires the program to visit two points on a graph, not just one. That being the case, it was simpler to use a recursive method with a signature that includes both the list of targets and the current position of your knight. A new visited set needs to be passed each time the moveSearch method is called so that each square can only be visited once per successful target.
### Grafix Map
Rather than trying to solve this problem using a BFS which could run on a time complexity near a  big O in factorial time, I used the UnionFind data structure to implement this solution. This solution currently runs in time complexity of O(n). The UnionFind made this solution. Once every cell was entered unto the UF structure, the method queried the UF for the list of connected lists. Any list who's root node was a zero was added to the return list. The returned values are the sizes of all of those lists.
### Largest Circle
The easy, brute-force, solution is to analize every possible radius, i.e. starting from the smalleat diameter divided of two, against every possible center point for both the X and Y axis against every possible (X,Y) coordinate to see of every cell along every curcumference is a space. The worst case computational complexity, that is when a graph has all spaces would be close to O(n^5)!
Using a UnionFind data structure, I successfully implemented a solution that has a computational complexity of O(n). I did this by filling the UF which took a time of O(n) and another O(n) to determine which rectangles existed in the input graph that were filled by spaces. Once that was done, determining where the largest circles were took a time of O(1).
### Revolving Doors
I implemented the solution for this problem as a Depth First Search (DFS) that attempts to find the target position first regardless of cost. The search is implemented as a recursive method that stores the current X and Y coordinates, the state of the doors, the current cost, a map that contains the visited count of every position, and a list that stores all unsatisified requests to open a door. Once the target is found the first, the method starts to return that cost as the maximum cost. Upon returning from a successful search, the method should look for successful paths that have a lesser cost than that maximum cost.
This solution works for some input, but not for all inputs. So, I need some help on this one.
### Small Toy Story
The construction of the constraints from the forbid list takes O(n^^4), which is not great, but the data set for forbidden is only 26 (the number of letters in the alphabet). The solution is a simple Breath First Search (BFS) that is performed recursivley in the private wordSearch method. This is done by initiating a queue of four letter words. The starting word is placed into the queue and the wordSearch method is called. This method loops through the queue checking if any word in the it is the word that finishes the search (the target word). If the word from the queue is not the finishing word, the method finds all other words that are one change (distance) from that word and enters them in the queue. The method calls itself recursively with the new words unitl t finds the target word. Each recursive call to adds one to the final score. Once the target word is found,  that is the score returned.
### Walking Home
This problem can be solved by running the Dijkstra's Shortest Path algorithm on a two dimensional graph/map. The fewestCrossing method takes the map and builds a distance matrix that will store the distance from the starting point to every other accessable point. A second matrix stores the "visited" status of each point. Once these matricies are initialized a second loop walks from the starting point to every point that is directly next to it. Each time, it keeps track of the cost it incurred it get to that point. If that cost is less than the cost that is on that point, it records the new cost as the lowest cost. Once this algorithm gets to the finishing point, the lower of recorded cost and the current cost will be the correct answer.

## General Algorithm Got-Yah's
To be written.

## Conclusion

I ask any viewers of this website that think that they have a better solution to any problem shown here, to please contact me.
